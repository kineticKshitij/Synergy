================================================================================
4. IMPLEMENTATION DETAILS
================================================================================

This section provides detailed implementation specifics for key components
of SynergyOS, including code examples, algorithms, and technical decisions.


4.1 Authentication System Implementation
--------------------------------------------------------------------------------

4.1.1 JWT Token Generation and Validation
..............................................................................

LIBRARY: djangorestframework-simplejwt 5.4.0

CONFIGURATION (settings.py):
```python
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(minutes=1440),  # 24 hours
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'UPDATE_LAST_LOGIN': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'AUTH_HEADER_TYPES': ('Bearer',),
}
```

TOKEN STRUCTURE:
Header:
{
  "typ": "JWT",
  "alg": "HS256"
}

Payload:
{
  "token_type": "access",
  "exp": 1699899234,      # Expiration timestamp
  "iat": 1699895634,      # Issued at timestamp
  "jti": "abc123...",     # JWT ID (unique)
  "user_id": 42
}

Signature:
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  SECRET_KEY
)

LOGIN VIEW IMPLEMENTATION (accounts/views.py):
```python
class LoginView(APIView):
    permission_classes = [AllowAny]
    serializer_class = LoginSerializer

    @ratelimit(key='ip', rate='5/5m', method='POST', block=True)
    def post(self, request):
        serializer = self.serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # Authenticate user
        username_or_email = serializer.validated_data['username']
        password = serializer.validated_data['password']
        
        user = authenticate(request, username=username_or_email, password=password)
        
        if user is None:
            # Log failed login
            SecurityEvent.objects.create(
                username=username_or_email,
                event_type='login_failed',
                ip_address=get_client_ip(request),
                description=f'Failed login attempt for {username_or_email}'
            )
            return Response({'error': 'Invalid credentials'}, status=401)
        
        # Generate tokens
        refresh = RefreshToken.for_user(user)
        
        # Log successful login
        SecurityEvent.objects.create(
            user=user,
            username=user.username,
            event_type='login_success',
            ip_address=get_client_ip(request),
            description=f'Successful login for {user.username}'
        )
        
        return Response({
            'access': str(refresh.access_token),
            'refresh': str(refresh),
            'user': UserSerializer(user).data
        })
```


4.1.2 Custom Authentication Backend
..............................................................................

Allows login with username OR email:

FILE: accounts/backends.py
```python
class EmailOrUsernameBackend(ModelBackend):
    """
    Custom authentication backend that allows users to login with either 
    username or email address.
    """
    def authenticate(self, request, username=None, password=None, **kwargs):
        try:
            # Check if username is an email
            if '@' in username:
                user = User.objects.get(email=username)
            else:
                user = User.objects.get(username=username)
        except User.DoesNotExist:
            return None
        
        # Verify password
        if user.check_password(password) and self.user_can_authenticate(user):
            return user
        return None
```

CONFIGURATION (settings.py):
```python
AUTHENTICATION_BACKENDS = [
    'accounts.backends.EmailOrUsernameBackend',
    'django.contrib.auth.backends.ModelBackend',
]
```


4.1.3 Rate Limiting Implementation
..............................................................................

LIBRARY: django-ratelimit 4.1.0

DECORATOR USAGE:
```python
from django_ratelimit.decorators import ratelimit

@ratelimit(key='ip', rate='5/5m', method='POST', block=True)
def login_view(request):
    # Login logic
    pass
```

CUSTOM MIDDLEWARE (accounts/middleware.py):
```python
class RateLimitMiddleware:
    """
    Middleware to handle rate limit errors and log them as security events.
    """
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)
        return response

    def process_exception(self, request, exception):
        if isinstance(exception, Ratelimited):
            # Log rate limit event
            SecurityEvent.objects.create(
                user=request.user if request.user.is_authenticated else None,
                username=request.user.username if request.user.is_authenticated else 'anonymous',
                event_type='rate_limit',
                ip_address=get_client_ip(request),
                description=f'Rate limit exceeded for {request.path}',
                metadata={'path': request.path, 'method': request.method}
            )
            return Response(
                {'error': 'Rate limit exceeded. Please try again later.'},
                status=429
            )
        return None
```

RATE LIMIT CONFIGURATION BY ENDPOINT:
- Login: 5 attempts per 5 minutes per IP
- Registration: 5 attempts per hour per IP
- Password reset: 3 attempts per hour per IP
- API endpoints: 100 requests per minute per user


4.1.4 Password Reset Flow
..............................................................................

STEP 1: Request password reset (POST /api/auth/password-reset/)
```python
class PasswordResetView(APIView):
    permission_classes = [AllowAny]
    
    @ratelimit(key='ip', rate='3/1h', method='POST', block=True)
    def post(self, request):
        email = request.data.get('email')
        
        try:
            user = User.objects.get(email=email)
            
            # Generate token
            token_generator = PasswordResetTokenGenerator()
            token = token_generator.make_token(user)
            uid = urlsafe_base64_encode(force_bytes(user.pk))
            
            # Build reset URL
            reset_url = f"{FRONTEND_URL}/reset-password/{uid}/{token}/"
            
            # Send email (via Celery)
            send_password_reset_email.delay(user.email, reset_url)
            
            # Log event
            SecurityEvent.objects.create(
                user=user,
                username=user.username,
                event_type='password_reset_request',
                ip_address=get_client_ip(request),
                description='Password reset requested'
            )
        except User.DoesNotExist:
            pass  # Don't reveal if email exists
        
        return Response({'message': 'Password reset email sent if account exists'})
```

STEP 2: Confirm password reset (POST /api/auth/password-reset-confirm/)
```python
class PasswordResetConfirmView(APIView):
    permission_classes = [AllowAny]
    
    def post(self, request):
        uid = request.data.get('uid')
        token = request.data.get('token')
        new_password = request.data.get('new_password')
        
        # Decode user ID
        try:
            user_id = force_str(urlsafe_base64_decode(uid))
            user = User.objects.get(pk=user_id)
        except (TypeError, ValueError, OverflowError, User.DoesNotExist):
            return Response({'error': 'Invalid reset link'}, status=400)
        
        # Validate token
        token_generator = PasswordResetTokenGenerator()
        if not token_generator.check_token(user, token):
            return Response({'error': 'Invalid or expired token'}, status=400)
        
        # Set new password
        user.set_password(new_password)
        user.save()
        
        # Log event
        SecurityEvent.objects.create(
            user=user,
            username=user.username,
            event_type='password_reset',
            ip_address=get_client_ip(request),
            description='Password successfully reset'
        )
        
        return Response({'message': 'Password reset successful'})
```


4.2 Project and Task Management Implementation
--------------------------------------------------------------------------------

4.2.1 Project Progress Calculation
..............................................................................

ALGORITHM: Weighted impact-based progress calculation

IMPLEMENTATION (projects/models.py):
```python
class Task(models.Model):
    # ... fields ...
    
    def save(self, *args, **kwargs):
        """Override save to update project progress when task status changes"""
        if self.pk:
            old_task = Task.objects.get(pk=self.pk)
            old_status = old_task.status
            new_status = self.status
            
            # If task is being marked as done
            if new_status == 'done' and old_status != 'done':
                self.completed_at = timezone.now()
            # If task is being unmarked from done
            elif old_status == 'done' and new_status != 'done':
                self.completed_at = None
        
        super().save(*args, **kwargs)
        self.update_project_progress()
    
    def update_project_progress(self):
        """Calculate and update project progress based on completed tasks' impact"""
        project = self.project
        tasks = project.tasks.all()
        
        # Calculate total impact of all tasks
        total_impact = sum(task.impact for task in tasks)
        
        if total_impact > 0:
            # Calculate impact of completed tasks
            completed_impact = sum(
                task.impact for task in tasks if task.status == 'done'
            )
            
            # Calculate progress percentage
            progress = min(100, int((completed_impact / total_impact) * 100))
        else:
            # Fallback: Simple task count
            total_tasks = tasks.count()
            completed_tasks = tasks.filter(status='done').count()
            progress = int((completed_tasks / total_tasks * 100)) if total_tasks > 0 else 0
        
        # Update project progress
        project.progress = progress
        project.save(update_fields=['progress'])
```

EXAMPLE SCENARIO:
Project with 3 tasks:
- Task A: impact=50.00, status=done
- Task B: impact=30.00, status=in_progress
- Task C: impact=20.00, status=todo

Calculation:
total_impact = 50 + 30 + 20 = 100
completed_impact = 50
progress = (50 / 100) * 100 = 50%


4.2.2 Task Filtering by Project
..............................................................................

PROBLEM: TaskViewSet initially returned all user-accessible tasks regardless
of project parameter in request.

SOLUTION: Modified get_queryset to filter by project query parameter.

IMPLEMENTATION (projects/views.py):
```python
class TaskViewSet(viewsets.ModelViewSet):
    serializer_class = TaskSerializer
    permission_classes = [IsAuthenticated, IsProjectOwner]
    
    def get_queryset(self):
        """Only return tasks from projects user has access to"""
        user = self.request.user
        queryset = Task.objects.filter(
            models.Q(project__owner=user) | models.Q(project__team_members=user)
        ).distinct()
        
        # Filter by project if provided
        project_id = self.request.query_params.get('project', None)
        if project_id is not None:
            queryset = queryset.filter(project_id=project_id)
        
        return queryset
```

API USAGE:
GET /api/tasks/               # All accessible tasks
GET /api/tasks/?project=7     # Only tasks from project 7


4.2.3 Permission System
..............................................................................

CUSTOM PERMISSION CLASS (projects/views.py):
```python
class IsProjectOwner(permissions.BasePermission):
    """
    Custom permission to only allow project owners to edit/delete projects.
    Team members have read-only access.
    """
    
    def has_object_permission(self, request, view, obj):
        # Read permissions for team members
        if request.method in permissions.SAFE_METHODS:
            # Check if user is owner or team member
            if hasattr(obj, 'owner'):
                return obj.owner == request.user or request.user in obj.team_members.all()
            elif hasattr(obj, 'project'):
                project = obj.project
                return project.owner == request.user or request.user in project.team_members.all()
        
        # Write permissions only for owner
        if hasattr(obj, 'owner'):
            return obj.owner == request.user
        elif hasattr(obj, 'project'):
            return obj.project.owner == request.user
        
        return False
```

USAGE IN VIEWSET:
```python
class ProjectViewSet(viewsets.ModelViewSet):
    serializer_class = ProjectSerializer
    permission_classes = [IsAuthenticated, IsProjectOwner]
```


4.2.4 Activity Logging
..............................................................................

Automatic logging of project activities:

```python
class ProjectViewSet(viewsets.ModelViewSet):
    def perform_create(self, serializer):
        """Log project creation"""
        project = serializer.save(owner=self.request.user)
        ProjectActivity.objects.create(
            project=project,
            user=self.request.user,
            action='project_created',
            description=f'Created project: {project.name}'
        )
    
    def perform_update(self, serializer):
        """Log project updates"""
        project = serializer.save()
        ProjectActivity.objects.create(
            project=project,
            user=self.request.user,
            action='project_updated',
            description=f'Updated project: {project.name}',
            metadata={'changes': serializer.validated_data.keys()}
        )
```


4.3 Webhook System Implementation
--------------------------------------------------------------------------------

4.3.1 Webhook Model with UUID Primary Key
..............................................................................

UUID advantages:
- Globally unique (no collisions)
- Non-sequential (security)
- Distributed system friendly

IMPLEMENTATION (webhooks/models.py):
```python
import uuid

class Webhook(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='webhooks')
    name = models.CharField(max_length=255)
    url = models.URLField(max_length=500)
    events = models.JSONField(default=list)
    secret = models.CharField(max_length=255, blank=True)
    is_active = models.BooleanField(default=True)
    
    # Statistics
    total_deliveries = models.IntegerField(default=0)
    successful_deliveries = models.IntegerField(default=0)
    failed_deliveries = models.IntegerField(default=0)
    last_triggered_at = models.DateTimeField(null=True, blank=True)
```


4.3.2 HMAC Signature Generation
..............................................................................

ALGORITHM: HMAC-SHA256 for webhook payload verification

IMPLEMENTATION (webhooks/utils.py):
```python
import hmac
import hashlib

def generate_webhook_signature(payload, secret):
    """
    Generate HMAC-SHA256 signature for webhook payload.
    
    Args:
        payload: JSON string of webhook payload
        secret: Webhook secret key
    
    Returns:
        Hex-encoded signature string
    """
    if not secret:
        return None
    
    signature = hmac.new(
        secret.encode('utf-8'),
        payload.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    
    return f"sha256={signature}"
```

VERIFICATION (Receiver side):
```python
def verify_webhook_signature(payload, signature, secret):
    """
    Verify webhook signature.
    
    Args:
        payload: JSON string received
        signature: Signature from X-Webhook-Signature header
        secret: Webhook secret key
    
    Returns:
        Boolean indicating if signature is valid
    """
    expected_signature = generate_webhook_signature(payload, secret)
    return hmac.compare_digest(signature, expected_signature)
```

USAGE IN DELIVERY:
```python
headers = {
    'Content-Type': 'application/json',
    'X-Webhook-Signature': generate_webhook_signature(payload_json, webhook.secret),
    'X-Webhook-ID': str(webhook.id),
    'X-Event-Type': event_type,
    'X-Delivery-ID': str(delivery.id)
}
```


4.3.3 Webhook Delivery with Celery
..............................................................................

CELERY TASK (webhooks/tasks.py):
```python
from celery import shared_task
import requests
import time

@shared_task(
    bind=True,
    max_retries=3,
    default_retry_delay=60  # 1 minute
)
def deliver_webhook(self, webhook_id, delivery_id):
    """
    Asynchronous webhook delivery task.
    
    Args:
        webhook_id: UUID of webhook
        delivery_id: UUID of delivery record
    """
    try:
        webhook = Webhook.objects.get(id=webhook_id)
        delivery = WebhookDelivery.objects.get(id=delivery_id)
    except (Webhook.DoesNotExist, WebhookDelivery.DoesNotExist):
        return
    
    # Prepare payload
    payload_json = json.dumps(delivery.payload)
    
    # Generate signature
    signature = generate_webhook_signature(payload_json, webhook.secret)
    
    # Prepare headers
    headers = {
        'Content-Type': 'application/json',
        'User-Agent': 'SynergyOS-Webhook/1.0',
        'X-Webhook-Signature': signature,
        'X-Webhook-ID': str(webhook.id),
        'X-Event-Type': delivery.event_type,
        'X-Delivery-ID': str(delivery.id),
        'X-Delivery-Attempt': str(delivery.retry_count + 1)
    }
    
    # Measure delivery time
    start_time = time.time()
    
    try:
        # Make HTTP POST request
        response = requests.post(
            webhook.url,
            data=payload_json,
            headers=headers,
            timeout=30
        )
        
        duration_ms = int((time.time() - start_time) * 1000)
        
        # Update delivery record
        delivery.status = 'success' if response.status_code < 400 else 'failed'
        delivery.response_status_code = response.status_code
        delivery.response_body = response.text[:1000]  # Truncate
        delivery.delivered_at = timezone.now()
        delivery.duration_ms = duration_ms
        delivery.save()
        
        # Update webhook statistics
        webhook.increment_delivery_stats(success=response.status_code < 400)
        
        # Retry on failure
        if response.status_code >= 400:
            raise Exception(f"HTTP {response.status_code}")
            
    except Exception as exc:
        # Update delivery record with error
        delivery.status = 'failed'
        delivery.error_message = str(exc)
        delivery.retry_count += 1
        delivery.save()
        
        # Retry with exponential backoff
        if delivery.retry_count < 3:
            retry_delay = 60 * (2 ** delivery.retry_count)  # 60s, 120s, 240s
            delivery.status = 'retrying'
            delivery.next_retry_at = timezone.now() + timedelta(seconds=retry_delay)
            delivery.save()
            
            raise self.retry(exc=exc, countdown=retry_delay)
        else:
            webhook.increment_delivery_stats(success=False)
```


4.3.4 Webhook Event Triggering
..............................................................................

SIGNAL HANDLER (webhooks/signals.py):
```python
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver

@receiver(post_save, sender=Project)
def trigger_project_webhook(sender, instance, created, **kwargs):
    """Trigger webhook on project creation or update"""
    event_type = 'project.created' if created else 'project.updated'
    
    # Find webhooks subscribed to this event
    webhooks = Webhook.objects.filter(
        user=instance.owner,
        is_active=True
    )
    
    for webhook in webhooks:
        if '*' in webhook.events or event_type in webhook.events:
            # Create payload
            payload = {
                'event': event_type,
                'timestamp': timezone.now().isoformat(),
                'data': {
                    'id': instance.id,
                    'name': instance.name,
                    'status': instance.status,
                    'priority': instance.priority,
                    'progress': instance.progress,
                    'owner': instance.owner.username
                }
            }
            
            # Create delivery record
            delivery = WebhookDelivery.objects.create(
                webhook=webhook,
                event_type=event_type,
                payload=payload,
                status='pending'
            )
            
            # Queue delivery task
            deliver_webhook.delay(str(webhook.id), str(delivery.id))


@receiver(post_save, sender=Task)
def trigger_task_webhook(sender, instance, created, **kwargs):
    """Trigger webhook on task creation or update"""
    if created:
        event_type = 'task.created'
    elif instance.status == 'done' and instance.completed_at:
        event_type = 'task.completed'
    else:
        event_type = 'task.updated'
    
    webhooks = Webhook.objects.filter(
        user=instance.project.owner,
        is_active=True
    )
    
    for webhook in webhooks:
        if '*' in webhook.events or event_type in webhook.events:
            payload = {
                'event': event_type,
                'timestamp': timezone.now().isoformat(),
                'data': {
                    'id': instance.id,
                    'project_id': instance.project.id,
                    'title': instance.title,
                    'status': instance.status,
                    'priority': instance.priority,
                    'assigned_to': instance.assigned_to.username if instance.assigned_to else None
                }
            }
            
            delivery = WebhookDelivery.objects.create(
                webhook=webhook,
                event_type=event_type,
                payload=payload,
                status='pending'
            )
            
            deliver_webhook.delay(str(webhook.id), str(delivery.id))
```


4.3.5 Webhook Cleanup Task
..............................................................................

SCHEDULED CLEANUP (webhooks/tasks.py):
```python
from celery import shared_task
from datetime import timedelta

@shared_task
def cleanup_expired_webhooks():
    """
    Delete old webhook delivery records (older than 30 days).
    Runs daily at 2 AM via Celery Beat.
    """
    cutoff_date = timezone.now() - timedelta(days=30)
    
    deleted_count, _ = WebhookDelivery.objects.filter(
        created_at__lt=cutoff_date
    ).delete()
    
    return f"Deleted {deleted_count} old webhook deliveries"
```

CELERY BEAT SCHEDULE (settings.py):
```python
CELERY_BEAT_SCHEDULE = {
    'cleanup-expired-webhooks': {
        'task': 'webhooks.tasks.cleanup_expired_webhooks',
        'schedule': crontab(hour=2, minute=0),  # Daily at 2 AM
    },
}
```


4.4 Frontend Implementation
--------------------------------------------------------------------------------

4.4.1 Authentication Context
..............................................................................

IMPLEMENTATION (app/contexts/AuthContext.tsx):
```typescript
import React, { createContext, useContext, useState, useEffect } from 'react';
import { jwtDecode } from 'jwt-decode';

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  
  useEffect(() => {
    // Check for existing token on mount
    const token = localStorage.getItem('access_token');
    if (token) {
      try {
        const decoded = jwtDecode(token);
        // Check if token is expired
        if (decoded.exp * 1000 > Date.now()) {
          fetchUserProfile();
        } else {
          logout();
        }
      } catch (error) {
        logout();
      }
    }
  }, []);
  
  const login = async (email: string, password: string) => {
    const response = await authService.login(email, password);
    localStorage.setItem('access_token', response.access);
    localStorage.setItem('refresh_token', response.refresh);
    setUser(response.user);
  };
  
  const logout = () => {
    const refreshToken = localStorage.getItem('refresh_token');
    if (refreshToken) {
      authService.logout(refreshToken);
    }
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');
    setUser(null);
  };
  
  return (
    <AuthContext.Provider value={{ user, login, logout, isAuthenticated: !!user }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```


4.4.2 Protected Route Component
..............................................................................

IMPLEMENTATION (app/components/ProtectedRoute.tsx):
```typescript
import { Navigate } from 'react-router';
import { useAuth } from '../contexts/AuthContext';

export const ProtectedRoute: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { isAuthenticated } = useAuth();
  
  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }
  
  return <>{children}</>;
};
```

USAGE IN ROUTES (app/routes.ts):
```typescript
export const routes = [
  {
    path: '/dashboard',
    element: <ProtectedRoute><Dashboard /></ProtectedRoute>
  },
  {
    path: '/projects/:id',
    element: <ProtectedRoute><ProjectDetail /></ProtectedRoute>
  }
];
```


4.4.3 API Service with Axios Interceptors
..............................................................................

IMPLEMENTATION (app/services/auth.service.ts):
```typescript
import axios from 'axios';

const API_URL = '/api/auth/';

// Create axios instance
const axiosInstance = axios.create({
  baseURL: API_URL
});

// Request interceptor: Add auth token to requests
axiosInstance.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('access_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor: Handle token refresh on 401
axiosInstance.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        const refreshToken = localStorage.getItem('refresh_token');
        const response = await axios.post(`${API_URL}token/refresh/`, {
          refresh: refreshToken
        });
        
        const { access } = response.data;
        localStorage.setItem('access_token', access);
        
        originalRequest.headers.Authorization = `Bearer ${access}`;
        return axiosInstance(originalRequest);
      } catch (refreshError) {
        // Refresh failed, logout user
        localStorage.removeItem('access_token');
        localStorage.removeItem('refresh_token');
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

export const authService = {
  async login(email: string, password: string) {
    const response = await axiosInstance.post('login/', { username: email, password });
    return response.data;
  },
  
  async logout(refreshToken: string) {
    await axiosInstance.post('logout/', { refresh: refreshToken });
  },
  
  async register(userData: any) {
    const response = await axiosInstance.post('register/', userData);
    return response.data;
  }
};
```


4.5 Celery Configuration and Tasks
--------------------------------------------------------------------------------

4.5.1 Celery Application Setup
..............................................................................

IMPLEMENTATION (backend/SynergyOS/celery.py):
```python
from celery import Celery
import os

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'SynergyOS.settings')

app = Celery('SynergyOS')
app.config_from_object('django.conf:settings', namespace='CELERY')
app.autodiscover_tasks()

@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}')
```

INIT FILE (backend/SynergyOS/__init__.py):
```python
from .celery import app as celery_app

__all__ = ('celery_app',)
```


4.5.2 Email Notification Task
..............................................................................

IMPLEMENTATION (accounts/tasks.py):
```python
from celery import shared_task
from django.core.mail import send_mail
from django.conf import settings

@shared_task(
    bind=True,
    max_retries=3,
    default_retry_delay=300  # 5 minutes
)
def send_password_reset_email(self, email, reset_url):
    """
    Send password reset email asynchronously.
    """
    try:
        subject = 'Password Reset Request - SynergyOS'
        message = f"""
        You requested a password reset for your SynergyOS account.
        
        Click the link below to reset your password:
        {reset_url}
        
        This link will expire in 1 hour.
        
        If you didn't request this, please ignore this email.
        """
        
        send_mail(
            subject,
            message,
            settings.DEFAULT_FROM_EMAIL,
            [email],
            fail_silently=False,
        )
    except Exception as exc:
        raise self.retry(exc=exc)
```


4.6 Docker Configuration
--------------------------------------------------------------------------------

4.6.1 Backend Dockerfile
..............................................................................

MULTI-STAGE BUILD (backend/Dockerfile):
```dockerfile
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy project
COPY . .

# Create directories for static files and media
RUN mkdir -p /app/staticfiles /app/media

# Run as non-root user
RUN useradd -m appuser && chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE 8000

# Command will be overridden by docker-compose
CMD ["gunicorn", "SynergyOS.wsgi:application", "--bind", "0.0.0.0:8000"]
```


4.6.2 Frontend Dockerfile
..............................................................................

MULTI-STAGE BUILD (frontend/Dockerfile):
```dockerfile
# Stage 1: Build
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY package.json package-lock.json ./

# Install dependencies
RUN npm ci

# Copy application files
COPY . .

# Build application
RUN npm run build

# Stage 2: Production
FROM node:20-alpine

WORKDIR /app

# Copy built files and dependencies
COPY --from=builder /app/build ./build
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./

# Expose port
EXPOSE 3000

# Start application
CMD ["npm", "start"]
```


4.7 Summary
--------------------------------------------------------------------------------

This implementation chapter detailed:
- JWT authentication with token rotation and blacklisting
- Custom authentication backend for email/username login
- Rate limiting with security event logging
- Password reset flow with email notifications
- Weighted task progress calculation algorithm
- Permission system for project access control
- Webhook system with HMAC signatures and Celery delivery
- Frontend authentication context and protected routes
- Axios interceptors for automatic token refresh
- Celery task configuration and retry logic
- Docker multi-stage builds for optimization

The implementations demonstrate best practices including:
- Security-first approach (rate limiting, input validation, HMAC)
- Asynchronous processing for non-blocking operations
- Proper error handling and retry mechanisms
- Type safety with TypeScript on frontend
- Containerization for consistent environments
- Comprehensive logging for audit trails
